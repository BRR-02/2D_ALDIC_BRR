
% For DIC exp with a hole
clear all
format compact
clf

addpath ../refinement
%% Define initial mesh and circle

c = [-2,-2;-1,-2;0,-2;1,-2;2,-2; 
    -2,-1;-1,-1;0,-1;1,-1;2,-1;
    -2,0;-1,0;0,0;1,0;2,0;
    -2,1;-1,1;0,1;1,1;2,1;
    -2,2;-1,2;0,2;1,2;2,2]; % outside rectangular coordinates
e4 = [1,2,7,6; 2,3,8,7; 3,4,9,8; 4,5,10,9;
    6,7,12,11; 7,8,13,12; 8,9,14,13; 9,10,15,14;
    11,12,17,16; 12,13,18,17; 13,14,19,18; 14,15,20,19;
    16,17,22,21; 17,18,23,22; 18,19,24,23; 19,20,25,24]; % elements

C = [0.5,0.5]; % circle center
R = 0.6; % circle radius
h = 1/64;

%% *** Do QrefineR
coordinates = c; elements4 = e4; irregular = zeros(0,3);
patch('Faces', elements4, 'Vertices', coordinates, 'Facecolor','none')
print -depsc2 'MeshEmptyQ'
while 1
  [~,mark4] = markCircle(coordinates,[],elements4,C,R,h);
  mark4 = find(mark4);
  [coordinates,elements4,irregular] = QrefineR(coordinates,elements4,irregular,mark4);
  if isempty(mark4)
    break
  end
end
clf
patch('Faces', elements4, 'Vertices', coordinates, 'Facecolor','none','linewidth',1.1)
axis equal; axis tight; set(gca,'fontsize',32);
print -depsc2 'MeshQrefineR_16'


%% *** Remove elements inside the circle

[~,markOutside4] = markCircleInside(coordinates,elements4,C,R);

clf
patch('Faces', elements4(markOutside4,:), 'Vertices', coordinates, 'Facecolor','none','linewidth',1.1)
axis equal; axis tight; set(gca,'fontsize',32);
print -depsc2 'MeshQrefineR_16'





%% Image threshold
Img = imread('oht_cfrp_00.tiff'); figure, imshow(Img);  % Read image
[gridx,gridy] = ginput(); 
Par=CircleFitByTaubin([gridx,gridy]); % Par = [xCenCoord, yCenCoord, rad]
 
ImgGaussFilt = imgaussfilt(imgaussfilt(Img,0.5),0.5); % Gaussian filter
%figure, imshow(ImgGaussFilt);

ImgMask = logical(ImgGaussFilt>20); figure, imshow(ImgMask);
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% bw = imbinarize(ImgGaussFilt,'adaptive','ForegroundPolarity','dark','Sensitivity',0.5);
% figure, imshow(bw);
% 
% bw = bwareaopen(bw,90); % removes all connected components (objects) that have fewer than P pixels 
% removeobjradius = 10; % remove all object containing fewer than 10 pixels 
% se = strel('disk',removeobjradius); bw = imclose(bw,se); imshow(bw);
% 
% bw=1-bw;imshow(bw) % Change concave hole to convex sphere
% props = regionprops(bw ,'Area','PixelIdxList','MajorAxisLength','MinorAxisLength');
% [~,indexOfMax] = max([props.Area]);
% approximateRadius =  props(indexOfMax).MajorAxisLength/2;
% 
% edgebws2 = edge(bw);
%             figure;imshow(edgebws2);title('Edge detection');
%             
% [row,col] = find(edgebws2==1);
% XY = [row,col];
% try Par=CircleFitByTaubin(XY); catch Par = [0,0,0]; end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
load('results_oht_cfrp_11_ws16_st4.mat');
coordinatesFEM = DICmesh.coordinatesFEM; coordinatesFEM0 = coordinatesFEM;
elementsFEM = DICmesh.elementsFEM; elementsFEM0 = elementsFEM;
irregular = zeros(0,3);

% Define circle
C = Par(1:2); % circle center
R = Par(3); % circle radius
h = 1;

% Generate Quadtree mesh
while 1
  [~,mark4] = markCircle(coordinatesFEM,[],elementsFEM,C,R,h);
  mark4 = find(mark4);
  [coordinatesFEM,elementsFEM,irregular] = QrefineR(coordinatesFEM,elementsFEM,irregular,mark4);
  if isempty(mark4)
    break
  end
end

% Remove elements within the center hole
[~,markOutside4] = markCircleInside(coordinatesFEM,elementsFEM,C,R);
elementsFEM = elementsFEM(markOutside4,:);

% Plot
clf; patch('Faces', elementsFEM, 'Vertices', coordinatesFEM, 'Facecolor','none','linewidth',1.1)
axis equal; axis tight; set(gca,'fontsize',32);


% Update mesh for considering hanging nodes
for tempj=1:size(irregular,1)
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,1:2), 'rows' );
    if Lia>0, elementsFEM(Locb,8)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,2:3), 'rows' );
    if Lia>0, elementsFEM(Locb,5)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,3:4), 'rows' );
    if Lia>0, elementsFEM(Locb,6)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,[4,1]), 'rows' );
    if Lia>0, elementsFEM(Locb,7)=irregular(tempj,3); end
    
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,[2,1]), 'rows' );
    if Lia>0, elementsFEM(Locb,8)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,[3,2]), 'rows' );
    if Lia>0, elementsFEM(Locb,5)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,[4,3]), 'rows' );
    if Lia>0, elementsFEM(Locb,6)=irregular(tempj,3); end
    [Lia, Locb] = ismember( [irregular(tempj,1:2)], elementsFEM(:,[1,4]), 'rows' );
    if Lia>0, elementsFEM(Locb,7)=irregular(tempj,3); end
end



 % Initialize variables U
 U0 = ResultDisp{1}.U;
 F_dispu = scatteredInterpolant( coordinatesFEM0(:,1),coordinatesFEM0(:,2),U0(1:2:end) );
 F_dispv = scatteredInterpolant( coordinatesFEM0(:,1),coordinatesFEM0(:,2),U0(2:2:end) );
 
 U2 = 0*coordinatesFEM(:);  
 temp = F_dispu(coordinatesFEMLevel2(:,1),coordinatesFEMLevel2(:,2)); U0Level2(1:2:end)=temp(:);
 temp = F_dispv(coordinatesFEMLevel2(:,1),coordinatesFEMLevel2(:,2)); U0Level2(2:2:end)=temp(:);
         
        
Plotdisp_show(UIter,coordinatesFEMLevel2,elementsFEMLevel2(:,1:4));

